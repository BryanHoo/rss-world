# 中栏未读过滤会话保留设计

日期：2026-02-28  
状态：已评审（待实现）  
范围：Reader 中栏文章列表（不改后端协议）

## 背景与目标

当前在“仅显示未读”语义下（包括 `unread` 视图，以及 `all/feed + showUnreadOnly=true`），文章一旦被标记已读，容易从中栏立即消失，影响连续阅读体验。  
目标是把中栏行为调整为：

1. 当前中栏会话里已经显示过的文章，即使后来变成已读，也不立刻消失。
2. 到下一次“中栏刷新边界”时，再按未读规则重新收敛并隐藏已读项。

用户确认的“刷新边界”定义为全算：

1. `loadSnapshot` 导致的中栏数据刷新
2. `selectedView` 切换
3. “仅显示未读”开关切换

## 方案选择

对比后采用方案 A（推荐）：

1. 在中栏列表组件维护会话级 `visibleArticleIds`（集合）。
2. 在未读过滤开启时，显示条件从“仅未读”改为“未读 OR 会话内已显示过”。
3. 在刷新边界触发时，重建会话集合，旧会话保留失效。

不采用全局 store 方案，避免增加跨组件状态耦合与维护成本。

## 架构与组件职责

### 1) `ArticleList`（主要改动点）

在列表组件内部新增会话可见集合（如 `sessionVisibleArticleIds`）：

1. 记录“本会话中曾被渲染展示过的文章 id”。
2. 仅在未读过滤语义激活时参与过滤判断。
3. 当触发刷新边界时，集合整体重建。

### 2) `appStore`（保持现状）

`markAsRead`、`selectedView`、`showUnreadOnly`、`articles` 的数据来源和行为保持不变。  
本设计不引入新的 store 字段，避免状态扩散。

## 数据流设计

### 阶段 A：会话初始化/重建

触发：`selectedView` 变化、`showUnreadOnly` 变化、`articles` 快照刷新。  
动作：根据当前过滤基线重建 `sessionVisibleArticleIds`。

### 阶段 B：会话内阅读

触发：右栏阅读导致 `markAsRead` 把某文章置为已读。  
动作：若该文章 id 已在会话集合中，则继续在中栏保留显示。

### 阶段 C：会话内新增可见项

触发：同一会话内出现新的可见文章（通常为未读）。  
动作：该文章首次被渲染后加入会话集合，后续若变已读也不立即消失。

### 阶段 D：下一次刷新边界

触发同“阶段 A”。  
动作：旧集合丢弃并重建；上轮会话里的已读保留项不再延续。

## 过滤语义定义

当未读过滤语义开启时（满足任一）：

1. `selectedView === 'unread'`
2. `showUnreadOnly === true` 且视图允许该开关生效

文章可见条件为：

1. `!article.isRead`
2. 或 `article.id ∈ sessionVisibleArticleIds`

当未读过滤语义关闭时，沿用现有基础过滤，不参考会话集合。

## 错误处理与边界

1. 视图隔离：切换视图即重建会话集合，避免跨视图污染。
2. 开关隔离：开关切换即重建，避免旧会话残留。
3. 快照一致性：`articles` 刷新后按新数据重建，避免引用失效 id。
4. 性能：集合成员判断 O(1)，总体仍为线性过滤，不引入额外高复杂度。

## 测试设计

在 `ArticleList` 相关测试中覆盖以下用例：

1. `unread` 视图：已显示文章变已读后仍可见。
2. `all/feed + showUnreadOnly=true`：已显示文章变已读后仍可见。
3. 会话内多个已显示文章依次变已读，均保持可见。
4. 切换 `selectedView` 后，会话重建，旧会话已读项不再保留。
5. 切换 `showUnreadOnly` 后，会话重建，旧会话已读项不再保留。
6. 可选补强：`articles` 快照更新触发重建，行为符合预期。

## 非目标

1. 不修改后端 API 与数据库结构。
2. 不调整自动标记已读时机与策略。
3. 不引入全局“会话保留”状态到 `appStore`。

## 风险与回滚

风险：

1. 会话重建时机若遗漏，可能出现“该消失未消失”或“仍然立刻消失”的边界问题。

缓解：

1. 明确仅在三类刷新边界重建。
2. 用测试固定行为，重点覆盖 `unread` 与 `showUnreadOnly` 两条路径。

回滚：

1. 仅涉及中栏过滤逻辑与测试，可按单文件改动回退，不影响数据层。

